package com.gazi.gazi_renew.mock;

import com.gazi.gazi_renew.route.domain.MyFindRoadSubPath;
import com.gazi.gazi_renew.route.service.port.MyFindRoadSubPathRepository;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class FakeMyFindRoadSubPathRepository implements MyFindRoadSubPathRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(1);
    private final List<MyFindRoadSubPath> data = new ArrayList<>();
    @Override
    public MyFindRoadSubPath save(MyFindRoadSubPath myFindRoadSubPath) {
        if (myFindRoadSubPath.getId() == null || myFindRoadSubPath.getId() == 0) {
            MyFindRoadSubPath createSubPath = MyFindRoadSubPath.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .trafficType(myFindRoadSubPath.getTrafficType())
                    .distance(myFindRoadSubPath.getDistance())
                    .sectionTime(myFindRoadSubPath.getSectionTime())
                    .stationCount(myFindRoadSubPath.getStationCount())
                    .way(myFindRoadSubPath.getWay())
                    .door(myFindRoadSubPath.getDoor())
                    .name(myFindRoadSubPath.getName())
                    .stationCode(myFindRoadSubPath.getStationCode())
                    .stations(myFindRoadSubPath.getStations())
                    .build();
            data.add(createSubPath);
            return createSubPath;
        } else {
            data.removeIf(item -> Objects.equals(item.getId(), myFindRoadSubPath.getId()));
            data.add(myFindRoadSubPath);
            return myFindRoadSubPath;
        }
    }

    @Override
    public List<MyFindRoadSubPath> findByMyFindRoadPathId(Long myFindRoadPathId) {
        return data.stream()
                .filter(myFindRoadSubPath -> myFindRoadSubPath.getMyFindRoad().getId().equals(myFindRoadPathId))
                .collect(Collectors.toList());
    }

    @Override
    public void deleteAll(List<MyFindRoadSubPath> myFindRoadSubPathList) {
        Set<Long> idsToDelete = myFindRoadSubPathList.stream()
                .map(MyFindRoadSubPath::getId)
                .collect(Collectors.toSet());

        data.removeIf(myFindRoadSubPath -> idsToDelete.contains(myFindRoadSubPath.getId()));
    }

}
