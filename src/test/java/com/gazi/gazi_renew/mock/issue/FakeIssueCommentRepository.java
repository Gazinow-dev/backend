package com.gazi.gazi_renew.mock.issue;

import com.gazi.gazi_renew.issue.domain.Issue;
import com.gazi.gazi_renew.issue.domain.IssueComment;
import com.gazi.gazi_renew.issue.service.port.IssueCommentRepository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class FakeIssueCommentRepository implements IssueCommentRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final List<IssueComment> data = new ArrayList<>();
    @Override
    public IssueComment saveComment(IssueComment issueComment) {
        if (issueComment.getIssueCommentId() == null || issueComment.getIssueCommentId() == 0) {
            IssueComment result = IssueComment.builder()
                    .issueCommentId(autoGeneratedId.incrementAndGet())
                    .issue(issueComment.getIssue())
                    .memberId(issueComment.getMemberId())
                    .issueCommentContent(issueComment.getIssueCommentContent())
                    .createdBy(issueComment.getCreatedBy())
                    .createdAt(issueComment.getCreatedAt())
                    .reportedCount(issueComment.getReportedCount())
                    .build();
            data.add(result);
            return result;
        }else {
            data.removeIf(issueComment1 -> Objects.equals(issueComment1.getIssueCommentId(), issueComment.getIssueCommentId()));
            data.add(issueComment);
            return issueComment;
        }
    }

    @Override
    public Page<IssueComment> getIssueComments(Pageable pageable, Long memberId) {
        List<IssueComment> collect = data.stream()
                .filter(issueComment -> issueComment.getMemberId().equals(memberId))
                .sorted(Comparator.comparing(IssueComment::getCreatedAt).reversed())
                .collect(Collectors.toList());

        int start = (int) pageable.getOffset();
        int end = Math.min(start + pageable.getPageSize(), data.size());

        List<IssueComment> pagedIssues = collect.subList(start, end);

        return new PageImpl<>(pagedIssues, pageable, data.size());
    }

    @Override
    public void updateIssueComment(IssueComment issueComment) {
        data.removeIf(existingIssueComment -> Objects.equals(existingIssueComment.getIssueCommentId(), issueComment.getIssueCommentId()));

        IssueComment result = IssueComment.builder()
                .issueCommentId(issueComment.getIssueCommentId())
                .issue(issueComment.getIssue())
                .memberId(issueComment.getMemberId())
                .issueCommentContent(issueComment.getIssueCommentContent())
                .createdBy(issueComment.getCreatedBy())
                .createdAt(issueComment.getCreatedAt())
                .reportedCount(issueComment.getReportedCount())
                .build();

        data.add(result);
    }

    @Override
    public void deleteComment(Long issueCommentId) {
        data.removeIf(existingIssueComment -> Objects.equals(existingIssueComment.getIssueCommentId(), issueCommentId));
    }

    @Override
    public Optional<IssueComment> findByIssueCommentId(Long issueCommentId) {
        return data.stream().filter(issueComment -> issueComment.getIssueCommentId().equals(issueCommentId))
                .findFirst();
    }

    @Override
    public int countByIssueId(Long issueId) {
        return data.stream().filter(issueComment -> issueComment.getIssue().getId().equals(issueId))
                .collect(Collectors.toList()).size();
    }
    @Override
    public Page<IssueComment> getIssueCommentByIssueId(Pageable pageable, Long issueId) {
        List<IssueComment> collect = data.stream()
                .filter(issueComment -> issueComment.getIssue().getId().equals(issueId))
                .sorted(Comparator.comparing(IssueComment::getCreatedAt).reversed())
                .collect(Collectors.toList());

        int start = (int) pageable.getOffset();
        int end = Math.min(start + pageable.getPageSize(), data.size());
        List<IssueComment> pagedIssues = collect.subList(start, end);

        return new PageImpl<>(pagedIssues, pageable, data.size());
    }

    @Override
    public void updateReportedCount(IssueComment issueComment) {
        data.removeIf(existingIssueComment -> Objects.equals(existingIssueComment.getIssueCommentId(), issueComment.getIssueCommentId()));

        IssueComment result = IssueComment.builder()
                .issueCommentId(issueComment.getIssueCommentId())
                .issue(issueComment.getIssue())
                .memberId(issueComment.getMemberId())
                .issueCommentContent(issueComment.getIssueCommentContent())
                .createdBy(issueComment.getCreatedBy())
                .createdAt(issueComment.getCreatedAt())
                .reportedCount(issueComment.getReportedCount())
                .build();

        data.add(result);
    }
}
